<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>spring boot技巧（一）之Enable注解使用 | zeody's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">spring boot技巧（一）之Enable注解使用</h1><a id="logo" href="/.">zeody's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">spring boot技巧（一）之Enable注解使用</h1><div class="post-meta">Dec 10, 2018</div><div class="post-content"><p>spring boot 中经常遇到这样的场景，老大让你写一个定时业务脚本、开启一个spring注解缓存，或者让你提供spring 异步支持。你的做法肯定是 @EnbaleScheduling+@Scheduled，@EnableCaching+@Cache，@EnableAsync+@Async 立马开始写逻辑了。但你是否真正了解其中的原理呢。之前有写过一个项目，是日志系统，其中要提供spring boot 注解支持，需要简化配置。</p>
<p>现在来研究一下这些功能具体是怎么实现的</p>
<p>先来看@EnableScheduling源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(SchedulingConfiguration.class)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个注解是一个混合注解，和其他注解的唯一区别就是多了一个@Import注解</p>
<p>通过查询spring api文档</p>
<blockquote>
<p>Indicates one or more @Configuration classes to import.<br>Provides functionality equivalent to the <import> element in Spring XML. Allows for importing @Configuration classes, ImportSelector and ImportBeanDefinitionRegistrar implementations, as well as regular component classes (as of 4.2; analogous to AnnotationConfigApplicationContext.register(java.lang.Class&lt;?&gt;…)).</import></p>
<p>表示要导入的一个或多个@Configuration类。<br>提供与Spring XML中的<import>元素等效的功能。 允许导入@Configuration类，ImportSelector和ImportBeanDefinitionRegistrar实现，以及常规组件类（从4.2开始;类似于AnnotationConfigApplicationContext.register（java.lang.Class &lt;？&gt; …））。</import></p>
</blockquote>
<p>可以看出，通过这个注解可以导入一些特定的配置类</p>
<p>这些特定类包括三种 </p>
<ul>
<li>@Configuration 注解的类</li>
<li>实现ImportSelector接口的类</li>
<li>实现ImportBeanDefinitionRegistrar接口的类</li>
</ul>
<h4 id="Configuration注解类"><a href="#Configuration注解类" class="headerlink" title="@Configuration注解类"></a>@Configuration注解类</h4><p>查看SchedulingConfiguration类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span>(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span><br><span class="line">	<span class="meta">@Role</span>(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title">scheduledAnnotationProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ScheduledAnnotationBeanPostProcessor();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现他是属于第一种，直接注册了一个ScheduledAnnotationBeanPostProcessor  Bean</p>
<p>简单介绍一下ScheduledAnnotationBeanPostProcessor这个类干了什么事，他实现了BeanPostProcessor类。在bean 初始化之后，通过AnnotatedElementUtils.getMergedRepeatableAnnotations()方法去拿到有@Scheduled和@Schedules注解的方法，并将其放在hashMap中供后续使用。</p>
<h4 id="实现ImportSelector接口的类"><a href="#实现ImportSelector接口的类" class="headerlink" title="实现ImportSelector接口的类"></a>实现ImportSelector接口的类</h4><p>查看EnableAsync实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AsyncConfigurationSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAsync &#123;</span><br><span class="line"></span><br><span class="line">	Class&lt;? extends Annotation&gt; annotation() <span class="keyword">default</span> Annotation.class;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到他通过导入AsyncConfigurationSelector类来开启异步支持，打开AsyncConfigurationSelector类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncConfigurationSelector</span> <span class="keyword">extends</span> <span class="title">AdviceModeImportSelector</span>&lt;<span class="title">EnableAsync</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME =</span><br><span class="line">			<span class="string">"org.springframework.scheduling.aspectj.AspectJAsyncConfiguration"</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (adviceMode) &#123;</span><br><span class="line">			<span class="keyword">case</span> PROXY:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; ProxyAsyncConfiguration.class.getName() &#125;;</span><br><span class="line">			<span class="keyword">case</span> ASPECTJ:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME &#125;;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AdviceModeImportSelector是一个抽象类，他实现了ImportSelector类的selectImports方法，并且自定义了实现，且留了一个抽象的口子可供使用</p>
<p>看一下api 文档</p>
<blockquote>
<p>Interface to be implemented by types that determine which @Configuration</p>
<p> class(es) should be imported based on a given selection criteria, usually one or more annotation attributes.</p>
<p>An <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/ImportSelector.html" target="_blank" rel="noopener"><code>ImportSelector</code></a> may implement any of the following <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/Aware.html" target="_blank" rel="noopener"><code>Aware</code></a> interfaces, and their respective methods will be called prior to <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/ImportSelector.html#selectImports-org.springframework.core.type.AnnotationMetadata-" target="_blank" rel="noopener"><code>selectImports(org.springframework.core.type.AnnotationMetadata)</code></a>:</p>
<ul>
<li><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/EnvironmentAware.html" target="_blank" rel="noopener"><code>EnvironmentAware</code></a></li>
<li><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactoryAware.html" target="_blank" rel="noopener"><code>BeanFactoryAware</code></a></li>
<li><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/BeanClassLoaderAware.html" target="_blank" rel="noopener"><code>BeanClassLoaderAware</code></a></li>
<li><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/ResourceLoaderAware.html" target="_blank" rel="noopener"><code>ResourceLoaderAware</code></a></li>
</ul>
<p>ImportSelectors are usually processed in the same way as regular <code>@Import</code> annotations, however, it is also possible to defer selection of imports until all <code>@Configuration</code> classes have been processed (see <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/DeferredImportSelector.html" target="_blank" rel="noopener"><code>DeferredImportSelector</code></a> for details).</p>
<p>通过一个给定选择标准的类型来确定导入哪些@Configuration，他和@Import的处理方式类似，只不过这个导入Configuration可以延迟到所有Configuration都加载完</p>
</blockquote>
<p>来说一下这一套体系的具体玩法</p>
<p>首先@EnableAsync 注解中是有一个AdviceMode 属性的，默认是PROXY，也可以指定ASPECTJ，表示动态代理的类型。</p>
<p>AdviceModeImportSelector 实现了selectImport方法，我们一般的有选项性的导入一个类肯定需要一些指明到底需要导入哪个类， AdviceModeImportSelector 虽然实现了大部分逻辑。但他留了个口子，抽象了另一个selectImport方法，这个口子需要你在注解中保留AdviceMode属性并提供默认值。</p>
<p>简单来说你自定义注解需要区分代理类型的话，可以按照这套规则（导入AdviceModeImportSelector的实现类）你只需要在当前类的注解中保留一个AdviceMode属性。当然你也可以直接导入ImportSelector 的自定义具体需要导入的配置。</p>
<p><strong>@EnableCaching 也是这种类型</strong></p>
<h4 id="实现ImportBeanDefinitionRegistrar接口的类"><a href="#实现ImportBeanDefinitionRegistrar接口的类" class="headerlink" title="实现ImportBeanDefinitionRegistrar接口的类"></a>实现ImportBeanDefinitionRegistrar接口的类</h4><p>查看@EnableAspectJAutoProxy</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解导入的时AspectJAutoProxyRegistrar类，AspectJAutoProxyRegistrar实现了</p>
<p>ImportBeanDefinitionRegistrar接口，实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">	AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">			AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">	<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">		AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">		AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口的两个参数，AnnotationMetadata 表示当前类的注解，BeanDefinitionRegistry 注册bean。</p>
<p>无论哪种方式，都只是一种思想，导入一种配置，你可以通过Configuration直接导入，也可以根据框架的代理类型有选择的导入，还可以不用直接实现自己的注册bean逻辑导入。</p>
</div><div class="tags"><a href="/tags/spring-boot/">spring boot</a></div><div class="post-nav"><a class="pre" href="/2019/03/05/源码分析rocketmq-环境搭建/">源码分析rocketmq--环境搭建</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://zeody.top"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/spring-boot/" style="font-size: 15px;">spring boot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/05/源码分析rocketmq-环境搭建/">源码分析rocketmq--环境搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/10/boot技巧（一）之Enable注解使用/">spring boot技巧（一）之Enable注解使用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">zeody's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>